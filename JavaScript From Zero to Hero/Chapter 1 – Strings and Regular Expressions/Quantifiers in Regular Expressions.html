<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Regular Expressions</title>

</head>

<body>
	<h1>Regular Expressions</h1>
	<p class='result' style="color:whitesmoke;font-size:26px;background-color: gray; min-height: 100px;">
		The output goes here!
	</p>
	<button id='clickBtn' style="color:black;font-size:19px;">Click Me
	</button>
	<script type="text/javascript">
		"use strict";
		/*
				В этом разделе вы узнаете о кванторах, используемых в регулярных выражениях. Кванторы указывают количество
		символов, которые могут повторяться в строке. Например, с помощью известного нам на данный момент синтаксиса регулярных выражений мы
		можем создать шаблон для сопоставления четырехзначных чисел следующим образом: /\d\d\d\d/. Но если нам нужно регулярное выражение, чтобы указать
		, сколько раз элемент должен повторяться, мы могли бы использовать специальные символы, известные как кванторы. Эту таблицу
		вы также можете найти на веб-сайте MDN.
		*/
		const btn = document.querySelector('#clickBtn');
		const pTag = document.querySelector('.result');

		// const myString = `Regular expressions are awesome!`;
		// const regPattern = /a+/g;
		/*
				Результатом является (a, a, a), потому что элемент ‘a’ трижды присутствует в приведенной выше myString (регулярные выражения - это
		круто). Давайте посмотрим, что произойдет, если мы заменим символ ‘+’ на ‘*’ в шаблоне.
		*/

		// const regPattern = /a*/g;
		/*
				Это связано с тем, что в конечный результат включен не только символ "a", но и пробелы, которые им предшествуют.
		Из таблицы вы можете видеть, что этот квантор найдет все вхождения символа и где он также
		расположен, но он будет искать ноль или более вхождений. Попробуйте этот шаблон для проверки наличия символа "d" и понаблюдайте за
		результатом.
		*/

		// const regPattern = /d*/g
		/*
				Таким образом, в строке нет символа "d", но он все равно вернет остальные символы, такие как пробелы или что
		-то еще, что им предшествует, и ожидается, что он ничему не будет соответствовать. Всякий раз, когда вы используете * и ?, вы должны знать, что это может соответствовать
		нулевым экземплярам и всему, что им предшествует. Хорошо, следующий квантор "?" работает аналогично "*", потому что он
		будет искать ноль или более вхождений. Например, если мы хотим сопоставить be, bee и bees одновременно, мы
		можем построить этот шаблон регулярного выражения: /be+s?/
		*/
		const myString = `Regular expressions are awesome!`;
		const regPattern = /s{2}/g
		/*
				Этот квантор будет соответствовать точному количеству вхождений элемента /символа, который мы ищем. Например,
		/s{2}/ не соответствует символу "s" в "awesome!", но он соответствует двум вхождениям символа "s" в ‘expressions’.
		Это происходит потому, что мы помещаем номер два внутри фигурных скобок, и если мы изменим это на /s{3}/, это не
		сработает, потому что нигде в строке нет этой последовательности из трех букв ‘sss’. По какой-то причине, если мы хотим
		сопоставить все вхождения символа ‘s’, то мы можем сделать это /s{1}/, и это даст нам все вхождения.
		Интересным моментом, который следует отметить, является то, что кванторы, такие как * и +, известны как "жадные", что означает, что они будут
		пытаться сопоставить как можно больше символов строки. Когда мы объединим их с квантором ‘?’, он больше
		не будет рассматриваться как жадный, потому что он остановится, как только найдет совпадение. Давайте сделаем еще один шаг вперед. 
		Например, давайте напишем выражение для сопоставления от трех до четырех цифр
		*/
		//regex to match a digit between 3 and 4
		let numbersString = "1 12 999 34 9888 687665";
		let regex1 = /\d{3,4}/g;

		console.log(numbersString.match(regex1));
		//output: ['999', '9888', '6876']
		/*
				Здесь я использовал метод match() для сопоставления строки с созданным нами регулярным выражением. Соответствующей строкой
		является строка numbers, а регулярным выражением в этом примере является regex1. Другой пример, который я хочу вам показать, - это
		когда нам нужно подобрать определенное слово. Например, это может быть JavaScript в каком-то длинном тексте, и нам нужно
		сопоставить его с одним или несколькими пробелами до и после слова. Взгляните на пошаговый процесс (‘Вы можете найти
		код в regex2.js файл’):
		*/

		/*__________________*/

		/*
				1) Сначала мы выполняем точное сопоставление слов следующим образом:
		*/

// 		let longString = `As we know, JavaScript is a scripting language that enables you to create dynamically updating content,
// control multimedia, animate images, and pretty much....`;
// 		let regex2 = /JavaScript/g;
// 		console.log(longString.match(regex2));
// 		//Output:[‘JavaScript’]

		/*
				2) Второй шаг - включить пробелы до и после. Специальным символом для пробелов был
		"s", если вы посмотрите на предыдущую таблицу, и нам нужно объединить его с символом "+", чтобы мы могли указать
		, что мы говорим, что в нем должен быть по крайней мере один пробел до после JavaScript.
		*/

		let longString = `As we know JavaScript is a scripting language that enables you to create dynamically updating content,
control multimedia, animate images, and pretty much....`;
		let regex2 = /\s+JavaScript\s+/g;
		console.log(longString.match(regex2));
		//Output:[‘ JavaScript ’]


		/*
				Хорошо, давайте обобщим то, что мы знаем на данный момент о регулярных выражениях. В регулярном выражении у нас есть несколько
		зарезервированных символов, которые имеют особые значения, например
		
		.
		+
		*
		?
		{}
		|
		()
		[]
		\
		^
		$

				Символ соответствует любому отдельному символу. Например, если мы хотим сопоставить совпадения этих двух слов, кэшированных
		с использованием одного шаблона, мы можем использовать это регулярное выражение /.matches./. Символ + означает, что повторение может быть 1 или
		более раз, а символ * указывает на 0 или более вхождений символа.
		В этом примере я не показывал вам, как мы можем это сделать внутри JavaScript. Это просто, и все, что вам нужно сделать, это
		создать литерал регулярного выражения и использовать метод тестирования, который я использовал в предыдущем примере. Если тестовый метод возвращает значение true, то
		подстрока, которую мы ищем, существует в более крупной или исходной строке. Но если вы просто хотите проверить, соответствует ли ваше регулярное
		выражение подстроке, которую вы ищете, вы можете просто воспользоваться веб-сайтом regexp, о котором я упоминал ранее. На
		этом веб-сайте, если у нас есть правильное регулярное выражение, то подстрока будет окрашена в синий цвет, как в этом примере:
		
		Quantifiers in Regular Expressions.png
		*/

		btn.addEventListener('click', (e) => {
			const result = myString.match(regPattern);
			pTag.innerHTML = result;
		});
	</script>
</body>

</html>